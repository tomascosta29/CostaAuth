===== File: ./cmd/costa-auth/main.go =====
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"github.com/tomascosta29/CostaAuth/internal/app"
	"github.com/tomascosta29/CostaAuth/internal/config"
	"github.com/tomascosta29/CostaAuth/internal/handler"
	"github.com/tomascosta29/CostaAuth/internal/repository"
	"github.com/tomascosta29/CostaAuth/internal/service"
)

func main() {
	// Load configuration
	cfg, err := config.LoadConfig(".env")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Initialize database connections
	userRepo, err := repository.NewSQLiteUserRepository("auth.db") // Use SQLite
	if err != nil {
		log.Fatal("failed to connect to SQLite", err)
	}

	// Choose TokenRepository implementation based on environment variable
	var tokenRepo repository.TokenRepository
	if cfg.TokenStore == "redis" {
		tokenRepo, err = repository.NewRedisTokenRepository(cfg.RedisAddress, cfg.RedisPassword)
		if err != nil {
			log.Fatal("Failed to create Redis client:", err)
		}
	} else if cfg.TokenStore == "inmemory" {
		tokenRepo = repository.NewInMemoryTokenRepository()
	} else {
		log.Fatalf("Invalid TOKEN_STORE environment variable: %s. Must be 'redis' or 'inmemory'.", cfg.TokenStore)
	}

	// Create the real bcryptPasswordChecker
	passwordChecker := service.NewBcryptPasswordChecker()

	// Initialize services
	userService := service.NewUserService(userRepo, passwordChecker)          // Inject passwordChecker
	tokenService := service.NewTokenService(tokenRepo, []byte(cfg.JWTSecret)) // Use selected tokenRepo

	// Initialize handlers
	authHandler := handler.NewAuthHandler(userService, tokenService)

	// Create router and register routes
	r := mux.NewRouter()
	authHandler.RegisterRoutes(r)

	// Create a server
	server := &http.Server{
		Addr:         ":" + cfg.Port,
		Handler:      r,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
	}

	// --- mTLS Setup (Conditional) ---
	if cfg.MTLSEnabled {
		tlsConfig, err := app.SetupTLSConfig(cfg)
		if err != nil {
			log.Fatal("Failed to setup TLS config:", err)
		}
		server.TLSConfig = tlsConfig
	}

	// Graceful shutdown setup
	idleConnsClosed := make(chan struct{})
	go func() {
		sigint := make(chan os.Signal, 1)
		signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
		<-sigint

		// We received an interrupt signal, shut down.
		log.Println("Shutting down server...")
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		if err := server.Shutdown(ctx); err != nil {
			// Error from closing listeners, or context timeout:
			log.Printf("HTTP server Shutdown: %v", err)
		}
		close(idleConnsClosed)
	}()

	// Start the server (with or without TLS)
	fmt.Printf("Starting server on port %s (mTLS: %t)\n", cfg.Port, cfg.MTLSEnabled)
	if cfg.MTLSEnabled {
		// Start with TLS
		// Use ListenAndServeTLS with empty strings for cert and key,
		// because they are already loaded in server.TLSConfig
		err = server.ListenAndServeTLS("", "") // Use ListenAndServeTLS
	} else {
		// Start without TLS
		err = server.ListenAndServe()
	}

	if err != http.ErrServerClosed {
		log.Fatalf("HTTP server ListenAndServe: %v", err)
	}

	<-idleConnsClosed
	log.Println("Server gracefully stopped")
}


===== File: ./internal/app/auth.go =====
package app

// could have your main app struct


===== File: ./internal/app/errors.go =====
package app

// custom error types go here


===== File: ./internal/app/tls.go =====
package app

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"os"

	"github.com/tomascosta29/CostaAuth/internal/config"
)

// SetupTLSConfig creates a *tls.Config for mTLS.
func SetupTLSConfig(cfg *config.Config) (*tls.Config, error) {
	// Load server certificate and private key
	cert, err := tls.LoadX509KeyPair(cfg.ServerCertFile, cfg.ServerKeyFile)
	if err != nil {
		return nil, fmt.Errorf("failed to load server key pair: %w", err)
	}

	// Load CA certificate (for client certificate verification)
	caCert, err := os.ReadFile(cfg.CACertFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read CA certificate: %w", err)
	}

	// Create a certificate pool and add the CA certificate
	caCertPool := x509.NewCertPool()
	if ok := caCertPool.AppendCertsFromPEM(caCert); !ok {
		return nil, fmt.Errorf("failed to append CA certificate to pool")
	}

	// Create the TLS configuration
	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},        // Server's certificate
		ClientAuth:   tls.RequireAndVerifyClientCert, // Require and verify client certs
		ClientCAs:    caCertPool,                     // CA pool for client verification
		MinVersion:   tls.VersionTLS12,               // Good practice: Enforce TLS 1.2 or higher
	}

	return tlsConfig, nil
}


===== File: ./internal/config/config.go =====
package config

import (
	"fmt"
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	Port           string
	RedisAddress   string
	RedisPassword  string
	JWTSecret      string
	TokenStore     string
	MTLSEnabled    bool   // mTLS enabled flag
	ServerCertFile string // Path to server cert
	ServerKeyFile  string // Path to server key
	CACertFile     string // Path to CA cert
}

func LoadConfig(envPath string) (*Config, error) {
	_ = godotenv.Load(envPath)

	cfg := &Config{
		Port:           os.Getenv("PORT"),
		RedisAddress:   os.Getenv("REDIS_ADDRESS"),
		RedisPassword:  os.Getenv("REDIS_PASSWORD"),
		JWTSecret:      os.Getenv("JWT_SECRET"),
		TokenStore:     os.Getenv("TOKEN_STORE"),
		MTLSEnabled:    os.Getenv("MTLS_ENABLED") == "true", // Convert to bool
		ServerCertFile: os.Getenv("SERVER_CERT_FILE"),
		ServerKeyFile:  os.Getenv("SERVER_KEY_FILE"),
		CACertFile:     os.Getenv("CA_CERT_FILE"),
	}

	if cfg.TokenStore == "" {
		return nil, fmt.Errorf("TOKEN_STORE environment variable must be set ('redis' or 'inmemory')")
	}

	if cfg.MTLSEnabled {
		if cfg.ServerCertFile == "" || cfg.ServerKeyFile == "" || cfg.CACertFile == "" {
			return nil, fmt.Errorf("MTLS_ENABLED is true, but SERVER_CERT_FILE, SERVER_KEY_FILE, and CA_CERT_FILE are not all set")
		}
	}

	return cfg, nil
}


===== File: ./internal/handler/auth_handler.go =====
package handler

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/tomascosta29/CostaAuth/internal/model"
	"github.com/tomascosta29/CostaAuth/internal/service"
)

type AuthHandler struct {
	userService  service.UserServiceInterface  // Use the interface
	tokenService service.TokenServiceInterface // Use the interface
}

func NewAuthHandler(userService service.UserServiceInterface, tokenService service.TokenServiceInterface) *AuthHandler {
	return &AuthHandler{userService: userService, tokenService: tokenService}
}

func (h *AuthHandler) RegisterRoutes(r *mux.Router) {
	r.HandleFunc("/auth/register", h.RegisterHandler).Methods("POST")
	r.HandleFunc("/auth/login", h.LoginHandler).Methods("POST")
	r.HandleFunc("/auth/refresh", h.RefreshHandler).Methods("POST")
	r.HandleFunc("/auth/logout", h.LogoutHandler).Methods("POST")
	r.HandleFunc("/auth/validate", h.ValidateTokenHandler).Methods("GET")
}

func (h *AuthHandler) RegisterHandler(w http.ResponseWriter, r *http.Request) {
	var req model.RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	_, err := h.userService.RegisterUser(r.Context(), &req)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest) // Or a different status code
		return
	}

	w.WriteHeader(http.StatusCreated) // 201 Created
	fmt.Fprintln(w, "User registered successfully")
}

func (h *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) {
	var req model.LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	user, err := h.userService.LoginUser(r.Context(), &req)
	if err != nil {
		http.Error(w, err.Error(), http.StatusUnauthorized)
		return
	}

	token, err := h.tokenService.GenerateToken(r.Context(), user.ID)
	if err != nil {
		http.Error(w, "Failed to generate token", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"token": token})
}

func (h *AuthHandler) RefreshHandler(w http.ResponseWriter, r *http.Request) {
	var req model.RefreshRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// in a real-world scenario you would retrieve the refresh token claims
	// here for simplicity's sake, and since its a mock, its not really implemented
	// so we just return a new token.
	// Refresh Token logic would include validating the Refresh token,
	// checking if its blacklisted, and issueing a new access token
	// (and potentially, a new refresh token)

	userID, _ := uuid.NewUUID() // Normally, extract user ID from refresh token
	accessToken, err := h.tokenService.GenerateToken(r.Context(), userID)
	if err != nil {
		http.Error(w, "Failed to generate access token", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"access_token": accessToken})
}

func (h *AuthHandler) ValidateTokenHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := r.Header.Get("Authorization")

	if authHeader == "" {
		http.Error(w, "Authorization header required", http.StatusUnauthorized)
		return
	}
	// JWT has "Bearer " prefix
	tokenString := authHeader[len("Bearer "):]

	claims, err := h.tokenService.ValidateToken(r.Context(), tokenString)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid token: %v", err), http.StatusUnauthorized)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(claims)
}

func (h *AuthHandler) LogoutHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := r.Header.Get("Authorization")
	if authHeader == "" {
		http.Error(w, "Authorization header required", http.StatusUnauthorized)
		return
	}
	tokenString := authHeader[len("Bearer "):]
	err := h.tokenService.RevokeToken(r.Context(), tokenString)
	if err != nil {
		http.Error(w, fmt.Sprintf("could not log out: %v", err), http.StatusUnauthorized)
	}
	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "Logged out successfully")
}


===== File: ./internal/handler/auth_handler_test.go =====
package handler

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/tomascosta29/CostaAuth/internal/model"
)

type MockUserService struct {
	mock.Mock
}

func (m *MockUserService) RegisterUser(ctx context.Context, req *model.RegisterRequest) (*model.User, error) {
	args := m.Called(ctx, req)
	if args.Get(0) == nil { // handle nil case
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserService) LoginUser(ctx context.Context, req *model.LoginRequest) (*model.User, error) {
	args := m.Called(ctx, req)
	if args.Get(0) == nil { // handle nil case
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserService) HashPassword(password string) (string, error) {
	args := m.Called(password)
	return args.String(0), args.Error(1)
}

// CheckPasswordHash compares a password with its hash
func (m *MockUserService) CheckPasswordHash(password, hash string) bool {
	args := m.Called(password, hash)
	return args.Bool(0)
}

type MockTokenService struct {
	mock.Mock
}

func (m *MockTokenService) GenerateToken(ctx context.Context, userID uuid.UUID) (string, error) {
	args := m.Called(ctx, userID)
	return args.String(0), args.Error(1)
}

func (m *MockTokenService) ValidateToken(ctx context.Context, tokenString string) (jwt.MapClaims, error) {
	args := m.Called(ctx, tokenString)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(jwt.MapClaims), args.Error(1) // cast to map
}

func (m *MockTokenService) RevokeToken(ctx context.Context, tokenString string) error {
	args := m.Called(ctx, tokenString)
	return args.Error(0)
}

func TestAuthHandler_RegisterHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Successful registration
	reqBody := `{"username": "testuser", "email": "test@example.com", "password": "password123"}`
	req, _ := http.NewRequest("POST", "/auth/register", bytes.NewBufferString(reqBody))
	recorder := httptest.NewRecorder()
	// Mock behavior for successful registration
	mockUserService.On("RegisterUser", mock.Anything, mock.AnythingOfType("*model.RegisterRequest")).Return(&model.User{}, nil)

	handler.RegisterHandler(recorder, req)

	assert.Equal(t, http.StatusCreated, recorder.Code)
	assert.Equal(t, "User registered successfully\n", recorder.Body.String())

	// Reset the mock for the next test case!  This is important.
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Invalid request body
	req, _ = http.NewRequest("POST", "/auth/register", bytes.NewBufferString("invalid json"))
	recorder = httptest.NewRecorder()

	handler.RegisterHandler(recorder, req)
	assert.Equal(t, http.StatusBadRequest, recorder.Code)

	// Reset the mock for the next test case
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Registration error (e.g., username already exists)
	req, _ = http.NewRequest("POST", "/auth/register", bytes.NewBufferString(reqBody)) // valid request
	recorder = httptest.NewRecorder()

	// Mock behavior for registration error
	mockUserService.On("RegisterUser", mock.Anything, mock.AnythingOfType("*model.RegisterRequest")).Return(nil, errors.New("some error"))

	handler.RegisterHandler(recorder, req)
	assert.Equal(t, http.StatusBadRequest, recorder.Code) // expect 400

	// The mock expectations must be asserted *AFTER* the handler call that uses the mock.
	mockUserService.AssertExpectations(t)
	mockTokenService.AssertExpectations(t)
}

func TestAuthHandler_LoginHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Successful login
	reqBody := `{"username": "testuser", "password": "password123"}`
	req, _ := http.NewRequest("POST", "/auth/login", bytes.NewBufferString(reqBody))
	recorder := httptest.NewRecorder()
	mockUserService.On("LoginUser", mock.Anything, mock.AnythingOfType("*model.LoginRequest")).Return(&model.User{ID: uuid.New()}, nil)
	mockTokenService.On("GenerateToken", mock.Anything, mock.AnythingOfType("uuid.UUID")).Return("testtoken", nil)

	handler.LoginHandler(recorder, req)

	assert.Equal(t, http.StatusOK, recorder.Code)
	var response map[string]string
	json.Unmarshal(recorder.Body.Bytes(), &response)
	assert.Equal(t, "testtoken", response["token"])

	// Reset mocks
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Invalid request body
	req, _ = http.NewRequest("POST", "/auth/login", bytes.NewBufferString("invalid json"))
	recorder = httptest.NewRecorder()

	handler.LoginHandler(recorder, req)
	assert.Equal(t, http.StatusBadRequest, recorder.Code)

	// Reset mocks
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Login error (e.g., user not found)
	req, _ = http.NewRequest("POST", "/auth/login", bytes.NewBufferString(reqBody)) // valid request
	recorder = httptest.NewRecorder()

	mockUserService.On("LoginUser", mock.Anything, mock.AnythingOfType("*model.LoginRequest")).Return(nil, errors.New("some error"))

	handler.LoginHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code) // expect 401

	// Assert expectations *after* the handler call and assertions.
	mockUserService.AssertExpectations(t)
	mockTokenService.AssertExpectations(t)
}

func TestAuthHandler_ValidateTokenHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Successful validation
	tokenString := "valid-token" // dummy
	req, _ := http.NewRequest("GET", "/auth/validate", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)
	recorder := httptest.NewRecorder()

	mockTokenService.On("ValidateToken", mock.Anything, tokenString).Return(jwt.MapClaims{"sub": "testuser"}, nil)

	handler.ValidateTokenHandler(recorder, req)

	assert.Equal(t, http.StatusOK, recorder.Code)
	var response map[string]interface{}

	json.Unmarshal(recorder.Body.Bytes(), &response)
	assert.Equal(t, "testuser", response["sub"])

	// Test case: missing header
	req, _ = http.NewRequest("GET", "/auth/validate", nil)
	recorder = httptest.NewRecorder()
	handler.ValidateTokenHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)

	// Test case: Invalid token
	req, _ = http.NewRequest("GET", "/auth/validate", nil)
	req.Header.Set("Authorization", "Bearer invalid-token")
	recorder = httptest.NewRecorder()

	mockTokenService.On("ValidateToken", mock.Anything, "invalid-token").Return(nil, assert.AnError)

	handler.ValidateTokenHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)

	mockUserService.AssertExpectations(t)
	mockTokenService.AssertExpectations(t)
}

func TestAuthHandler_LogoutHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)
	tokenString := "valid-token" // dummy

	// Test case: Successful logout
	req, _ := http.NewRequest("POST", "/auth/logout", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)
	recorder := httptest.NewRecorder()
	mockTokenService.On("RevokeToken", mock.Anything, tokenString).Return(nil)

	handler.LogoutHandler(recorder, req)

	assert.Equal(t, http.StatusOK, recorder.Code)

	// Test case: missing header
	req, _ = http.NewRequest("POST", "/auth/logout", nil)
	recorder = httptest.NewRecorder()
	handler.LogoutHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)

	// Test case: Revoke token error
	req, _ = http.NewRequest("POST", "/auth/logout", nil)
	req.Header.Set("Authorization", "Bearer invalid-token")
	recorder = httptest.NewRecorder()
	mockTokenService.On("RevokeToken", mock.Anything, "invalid-token").Return(assert.AnError)
	handler.LogoutHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)
	mockTokenService.AssertExpectations(t)
	mockUserService.AssertExpectations(t)
}


===== File: ./internal/handler/middleware.go =====
package handler

import (
	"fmt"
	"net/http"

	"github.com/tomascosta29/CostaAuth/internal/service"
)

// AuthMiddleware is a middleware function that checks for a valid JWT
func AuthMiddleware(tokenService *service.TokenService) func(next http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			authHeader := r.Header.Get("Authorization")
			if authHeader == "" {
				http.Error(w, "Authorization header required", http.StatusUnauthorized)
				return
			}

			// JWT has "Bearer " prefix
			tokenString := authHeader[len("Bearer "):]

			_, err := tokenService.ValidateToken(r.Context(), tokenString)
			if err != nil {
				http.Error(w, fmt.Sprintf("Invalid token: %v", err), http.StatusUnauthorized)
				return
			}

			// Token is valid, proceed to the next handler
			next.ServeHTTP(w, r)
		})
	}
}


===== File: ./internal/model/user.go =====
package model

import "github.com/google/uuid"

type User struct {
	ID           uuid.UUID `json:"id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"-"` // Don't serialize the password hash
	CreatedAt    int64     `json:"created_at"`
	UpdatedAt    int64     `json:"updated_at"`
	IsActive     bool      `json:"is_active"`
}


===== File: ./internal/model/token.go =====
package model

type Token struct {
	JTI   string `json:"jti"` // used for blacklisting
	Token string `json:"token"`
}


===== File: ./internal/model/request.go =====
package model

type LoginRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type RegisterRequest struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type RefreshRequest struct {
	RefreshToken string `json:"refresh_token"`
}


===== File: ./internal/repository/user_repository.go =====
package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/tomascosta29/CostaAuth/internal/model"
)

type UserRepository interface {
	CreateUser(ctx context.Context, user *model.User) error
	GetUserByUsername(ctx context.Context, username string) (*model.User, error)
	GetUserByID(ctx context.Context, id uuid.UUID) (*model.User, error)
	GetUserByEmail(ctx context.Context, email string) (*model.User, error)
}


===== File: ./internal/repository/user_repository_sqlite.go =====
package repository

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/google/uuid"
	_ "github.com/mattn/go-sqlite3" // Import the SQLite driver
	"github.com/tomascosta29/CostaAuth/internal/model"
	// Import the SQLite driver
)

type SQLiteUserRepository struct {
	db *sql.DB
}

func NewSQLiteUserRepository(dbPath string) (*SQLiteUserRepository, error) {
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Ensure the database is properly closed on application exit.  Good practice.
	//  In a real app, you might want to handle graceful shutdowns more carefully.
	// go func() {
	// 	<-ctx.Done() //usually you have a ctx passed down to main
	// 	db.Close()
	// }()

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	// Create the users table if it doesn't exist
	if err := createUsersTable(db); err != nil {
		return nil, fmt.Errorf("failed to create users table: %w", err)
	}

	return &SQLiteUserRepository{db: db}, nil
}

func createUsersTable(db *sql.DB) error {
	createTableSQL := `
		CREATE TABLE IF NOT EXISTS users (
			id TEXT PRIMARY KEY,
			username TEXT NOT NULL UNIQUE,
			email TEXT NOT NULL UNIQUE,
			password_hash TEXT NOT NULL,
			created_at INTEGER NOT NULL,
			updated_at INTEGER NOT NULL,
			is_active INTEGER NOT NULL
		);
	`
	_, err := db.Exec(createTableSQL)
	return err
}

func (r *SQLiteUserRepository) CreateUser(ctx context.Context, user *model.User) error {
	user.ID = uuid.New()
	user.CreatedAt = time.Now().Unix()
	user.UpdatedAt = user.CreatedAt
	user.IsActive = true // default

	stmt, err := r.db.PrepareContext(ctx, "INSERT INTO users (id, username, email, password_hash, created_at, updated_at, is_active) VALUES (?, ?, ?, ?, ?, ?, ?)")
	if err != nil {
		return fmt.Errorf("failed to prepare insert statement: %w", err)
	}
	defer stmt.Close() // Important: Close the statement after use

	_, err = stmt.ExecContext(ctx, user.ID, user.Username, user.Email, user.PasswordHash, user.CreatedAt, user.UpdatedAt, user.IsActive)
	if err != nil {
		return fmt.Errorf("failed to insert user: %w", err)
	}

	return nil
}

func (r *SQLiteUserRepository) GetUserByUsername(ctx context.Context, username string) (*model.User, error) {
	user := &model.User{}
	row := r.db.QueryRowContext(ctx, "SELECT id, username, email, password_hash, created_at, updated_at, is_active FROM users WHERE username = ?", username)
	err := row.Scan(&user.ID, &user.Username, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt, &user.IsActive)
	if err == sql.ErrNoRows {
		return nil, nil // User not found, return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("failed to query user by username: %w", err)
	}
	return user, nil
}

func (r *SQLiteUserRepository) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	user := &model.User{}
	row := r.db.QueryRowContext(ctx, "SELECT id, username, email, password_hash, created_at, updated_at, is_active FROM users WHERE email = ?", email)
	err := row.Scan(&user.ID, &user.Username, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt, &user.IsActive)
	if err == sql.ErrNoRows {
		return nil, nil // User not found, return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("failed to query user by email: %w", err)
	}
	return user, nil
}

func (r *SQLiteUserRepository) GetUserByID(ctx context.Context, id uuid.UUID) (*model.User, error) {
	user := &model.User{}
	row := r.db.QueryRowContext(ctx, "SELECT id, username, email, password_hash, created_at, updated_at, is_active FROM users WHERE id = ?", id)
	err := row.Scan(&user.ID, &user.Username, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt, &user.IsActive)
	if err == sql.ErrNoRows {
		return nil, nil // User not found
	} else if err != nil {
		return nil, fmt.Errorf("failed to query user by ID: %w", err)
	}
	return user, nil
}


===== File: ./internal/repository/user_repository_sqlite_test.go =====
package repository

import (
	"context"
	"database/sql"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/tomascosta29/CostaAuth/internal/model"

	_ "github.com/mattn/go-sqlite3"
)

// Helper function to create a test database
func setupTestDB(t *testing.T) *sql.DB {
	db, err := sql.Open("sqlite3", ":memory:") // In-memory database
	require.NoError(t, err)

	err = createUsersTable(db)
	require.NoError(t, err)

	return db
}

func TestSQLiteUserRepository_CreateUser(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	user := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}

	err := repo.CreateUser(ctx, user)
	assert.NoError(t, err)
	assert.NotEqual(t, uuid.Nil, user.ID) // Check that ID was generated
}

func TestSQLiteUserRepository_GetUserByUsername(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	// Create a test user first
	existingUser := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}
	err := repo.CreateUser(ctx, existingUser)
	require.NoError(t, err)

	// Retrieve the user by username
	retrievedUser, err := repo.GetUserByUsername(ctx, "testuser")
	assert.NoError(t, err)
	assert.NotNil(t, retrievedUser)
	assert.Equal(t, existingUser.Username, retrievedUser.Username)
	assert.Equal(t, existingUser.Email, retrievedUser.Email)
	assert.Equal(t, existingUser.PasswordHash, retrievedUser.PasswordHash)

	// Test case: User not found
	retrievedUser, err = repo.GetUserByUsername(ctx, "nonexistentuser")
	assert.NoError(t, err) // No error should occur
	assert.Nil(t, retrievedUser)
}

func TestSQLiteUserRepository_GetUserByEmail(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	// Create a test user first
	existingUser := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}
	err := repo.CreateUser(ctx, existingUser)
	require.NoError(t, err)

	// Retrieve the user by email
	retrievedUser, err := repo.GetUserByEmail(ctx, "test@example.com")
	assert.NoError(t, err)
	assert.NotNil(t, retrievedUser)
	assert.Equal(t, existingUser.Username, retrievedUser.Username)

	// Test case: User not found
	retrievedUser, err = repo.GetUserByEmail(ctx, "nonexistentuser@email.com")
	assert.NoError(t, err)
	assert.Nil(t, retrievedUser)
}

func TestSQLiteUserRepository_GetUserByID(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	// Create a test user
	existingUser := &model.User{
		Username:     "testuser2",
		Email:        "test2@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}
	err := repo.CreateUser(ctx, existingUser)
	require.NoError(t, err)

	retrievedUser, err := repo.GetUserByID(ctx, existingUser.ID)
	assert.NoError(t, err)
	assert.NotNil(t, retrievedUser)
	assert.Equal(t, existingUser.ID, retrievedUser.ID)

	// Test case: User not found
	randomID := uuid.New()
	retrievedUser, err = repo.GetUserByID(ctx, randomID)
	assert.NoError(t, err)
	assert.Nil(t, retrievedUser)
}


===== File: ./internal/repository/token_repository_redis_test.go =====
package repository

import (
	"context"
	"testing"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/stretchr/testify/assert"
)

// Mock Redis for testing (can also use a real Redis instance if available)
type MockRedisClient struct {
	data map[string]string
}

func (m *MockRedisClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	if m.data == nil {
		m.data = make(map[string]string)
	}
	m.data[key] = value.(string) // Simple mock, assuming string values
	// Simulate expiration (simplified)
	if expiration > 0 {
		time.AfterFunc(expiration, func() {
			delete(m.data, key)
		})
	}
	return redis.NewStatusResult("", nil) // No error in mock
}

func (m *MockRedisClient) Get(ctx context.Context, key string) *redis.StringCmd {
	if m.data == nil {
		return redis.NewStringResult("", redis.Nil) // Key not found
	}
	val, ok := m.data[key]
	if !ok {
		return redis.NewStringResult("", redis.Nil)
	}
	return redis.NewStringResult(val, nil)
}

func (m *MockRedisClient) Ping(ctx context.Context) *redis.StatusCmd {
	return redis.NewStatusResult("PONG", nil) // No error in mock
}

func TestRedisTokenRepository_RevokeToken(t *testing.T) {
	mockClient := &MockRedisClient{}
	repo := &RedisTokenRepository{client: mockClient} // Use the mock
	ctx := context.Background()

	jti := "test-jti"
	expiration := time.Minute

	err := repo.RevokeToken(ctx, jti, expiration)
	assert.NoError(t, err)

	// Check if the token is revoked (using the mock)
	isRevoked, err := repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.True(t, isRevoked)

	// Wait longer than expiration
	time.Sleep(expiration + time.Millisecond*100) // add margin
	isRevoked, err = repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.False(t, isRevoked, "token should be expired")
}

func TestRedisTokenRepository_IsTokenRevoked(t *testing.T) {
	mockClient := &MockRedisClient{}
	repo := &RedisTokenRepository{client: mockClient}
	ctx := context.Background()

	jti := "another-test-jti"

	// Initially, the token should not be revoked
	isRevoked, err := repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.False(t, isRevoked)

	// Revoke the token
	err = repo.RevokeToken(ctx, jti, time.Minute)
	assert.NoError(t, err)

	// Now it should be revoked
	isRevoked, err = repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.True(t, isRevoked)
}

//For real integration test, you can use this (commented out) and replace MockRedisClient with a real client.
/*
func TestRedisTokenRepository_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	repo, err := NewRedisTokenRepository("localhost:6379", "") // Use a real Redis
    require.NoError(t, err)
	ctx := context.Background()

	jti := "integration-test-jti"
	expiration := time.Minute

	err = repo.RevokeToken(ctx, jti, expiration)
	assert.NoError(t, err)

	isRevoked, err := repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.True(t, isRevoked)

    time.Sleep(expiration + time.Millisecond*100)
    isRevoked, err = repo.IsTokenRevoked(ctx, jti)
    assert.NoError(t, err)
    assert.False(t, isRevoked)
}
*/


===== File: ./internal/repository/token_repository_redis.go =====
package repository

import (
	"context"
	"time"

	"github.com/go-redis/redis/v8"
)

type RedisTokenRepository struct {
	client RedisClient
}

func NewRedisTokenRepository(address, password string) (*RedisTokenRepository, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     address,
		Password: password, // No password set
		DB:       0,        // Use default DB
	})

	_, err := client.Ping(context.Background()).Result()
	if err != nil {
		return nil, err
	}

	return &RedisTokenRepository{client: client}, nil
}

func (r *RedisTokenRepository) RevokeToken(ctx context.Context, jti string, expiration time.Duration) error {
	return r.client.Set(ctx, jti, "revoked", expiration).Err() // key, value, expiration
}

func (r *RedisTokenRepository) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	val, err := r.client.Get(ctx, jti).Result()
	if err == redis.Nil { // key not found == not blacklisted
		return false, nil
	} else if err != nil {
		return false, err
	}
	// If the key exists, the token is revoked
	return val == "revoked", nil
}


===== File: ./internal/repository/token_repository.go =====
package repository

import (
	"context"
	"time"

	"github.com/go-redis/redis/v8"
)

type TokenRepository interface {
	RevokeToken(ctx context.Context, jti string, expiration time.Duration) error
	IsTokenRevoked(ctx context.Context, jti string) (bool, error)
}

type RedisClient interface {
	Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd
	Get(ctx context.Context, key string) *redis.StringCmd
	Ping(ctx context.Context) *redis.StatusCmd
}


===== File: ./internal/repository/token_repository_inmemory.go =====
package repository

import (
	"context"
	"sync"
	"time"
)

// InMemoryTokenRepository is an in-memory implementation of TokenRepository.
// It's suitable for development, testing, and single-instance deployments.
type InMemoryTokenRepository struct {
	blacklist map[string]time.Time // Stores JTI -> Expiration Time
	mu        sync.RWMutex         // Protects concurrent access to the map
}

// NewInMemoryTokenRepository creates a new InMemoryTokenRepository.
func NewInMemoryTokenRepository() *InMemoryTokenRepository {
	return &InMemoryTokenRepository{
		blacklist: make(map[string]time.Time),
	}
}

// RevokeToken adds a token's JTI to the blacklist with an expiration time.
func (r *InMemoryTokenRepository) RevokeToken(ctx context.Context, jti string, expiration time.Duration) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Convert duration to expiration time
	expireAt := time.Now().Add(expiration)

	r.blacklist[jti] = expireAt

	// go routine to clean up
	go r.cleanup(jti, expiration)
	return nil
}

// IsTokenRevoked checks if a token's JTI is present in the blacklist.
func (r *InMemoryTokenRepository) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	expireAt, ok := r.blacklist[jti]
	if !ok {
		return false, nil // Not found, so not revoked
	}

	// Check if the token has expired
	if time.Now().After(expireAt) {
		// it is expired, so remove it
		return false, nil
	}

	return true, nil // Found, and not expired, so it's revoked
}

// cleanup removes the JTI from the map when it is expired
func (r *InMemoryTokenRepository) cleanup(jti string, expiration time.Duration) {
	time.Sleep(expiration)

	r.mu.Lock()
	defer r.mu.Unlock()
	delete(r.blacklist, jti)
}


===== File: ./internal/service/token_service.go =====
package service

import (
	"context"
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/tomascosta29/CostaAuth/internal/repository"
)

// Add this interface! Crucial for mocking the service for handler testing.
type TokenServiceInterface interface {
	GenerateToken(ctx context.Context, userID uuid.UUID) (string, error)
	ValidateToken(ctx context.Context, tokenString string) (jwt.MapClaims, error)
	RevokeToken(ctx context.Context, tokenString string) error
}

type TokenService struct {
	tokenRepo repository.TokenRepository
	jwtSecret []byte
}

func NewTokenService(tokenRepo repository.TokenRepository, jwtSecret []byte) *TokenService {
	return &TokenService{tokenRepo: tokenRepo, jwtSecret: jwtSecret}
}

// GenerateToken generates a new JWT
func (s *TokenService) GenerateToken(ctx context.Context, userID uuid.UUID) (string, error) {
	// Create the Claims
	claims := jwt.MapClaims{
		"sub": userID.String(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 1).Unix(), // 1-hour expiration
		"jti": uuid.New().String(),                  // Unique JWT ID
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	ss, err := token.SignedString(s.jwtSecret)
	return ss, err
}

// ValidateToken validates a JWT and returns the claims if valid
func (s *TokenService) ValidateToken(ctx context.Context, tokenString string) (jwt.MapClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.jwtSecret, nil
	})
	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		// Check if the token is revoked
		jti, ok := claims["jti"].(string) // extract jti
		if !ok {
			return nil, fmt.Errorf("invalid token: missing jti")
		}
		isRevoked, err := s.tokenRepo.IsTokenRevoked(ctx, jti) // check if blacklisted
		if err != nil {
			return nil, fmt.Errorf("error checking token revocation status: %v", err)
		}
		if isRevoked {
			return nil, fmt.Errorf("token has been revoked")
		}

		return claims, nil
	} else {
		return nil, fmt.Errorf("invalid token")
	}
}

func (s *TokenService) RevokeToken(ctx context.Context, tokenString string) error {
	claims, err := s.ValidateToken(ctx, tokenString) // validate first
	if err != nil {
		return err
	}
	jti, ok := claims["jti"].(string) // extract jti
	if !ok {
		return fmt.Errorf("invalid token: missing jti")
	}
	exp, ok := claims["exp"].(float64)
	if !ok {
		return fmt.Errorf("invalid token: missing expiration")
	}
	expirationTime := time.Unix(int64(exp), 0)
	durationUntilExpiration := time.Until(expirationTime)

	return s.tokenRepo.RevokeToken(ctx, jti, durationUntilExpiration)
}


===== File: ./internal/service/token_service_test.go =====
package service

import (
	"context"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// --- Mock TokenRepository ---

// MockTokenRepository is a mock implementation of the TokenRepository interface.
type MockTokenRepository struct {
	mock.Mock // Use testify/mock for easy mocking
}

// RevokeToken is the mock implementation for RevokeToken.
func (m *MockTokenRepository) RevokeToken(ctx context.Context, jti string, expiration time.Duration) error {
	args := m.Called(ctx, jti, expiration) // Record the call
	return args.Error(0)                   // Return configured error (or nil)
}

// IsTokenRevoked is the mock implementation for IsTokenRevoked.
func (m *MockTokenRepository) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	args := m.Called(ctx, jti)         // Record the call
	return args.Bool(0), args.Error(1) // Return configured values (bool and error)
}

// --- Test Cases ---

func TestTokenService_GenerateToken(t *testing.T) {
	mockRepo := new(MockTokenRepository)                             // Create an instance of our mock
	tokenService := NewTokenService(mockRepo, []byte("test-secret")) // Inject the mock
	ctx := context.Background()
	userID := uuid.New()

	tokenString, err := tokenService.GenerateToken(ctx, userID)

	assert.NoError(t, err)          // Assert no error during generation
	assert.NotEmpty(t, tokenString) // Assert token string is not empty

	// Basic parsing to check structure (optional, but good for sanity)
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		return []byte("test-secret"), nil // Provide the signing key
	})
	assert.NoError(t, err)
	assert.True(t, token.Valid)

	claims, ok := token.Claims.(jwt.MapClaims)
	assert.True(t, ok)
	assert.Equal(t, userID.String(), claims["sub"]) // Check subject claim

	mockRepo.AssertExpectations(t) // Ensure mock was used as expected (it wasn't, but good practice)
}

func TestTokenService_ValidateToken_Valid(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()
	userID := uuid.New()

	// Generate a valid token (we'll use the *real* GenerateToken for this)
	validTokenString, err := tokenService.GenerateToken(ctx, userID)
	assert.NoError(t, err)

	// Configure the mock: IsTokenRevoked should return false (not revoked)
	mockRepo.On("IsTokenRevoked", ctx, mock.AnythingOfType("string")).Return(false, nil)

	// Call ValidateToken
	claims, err := tokenService.ValidateToken(ctx, validTokenString)

	// Assertions
	assert.NoError(t, err)                          // No error should occur
	assert.NotNil(t, claims)                        // Claims should be returned
	assert.Equal(t, userID.String(), claims["sub"]) // Check the subject

	mockRepo.AssertExpectations(t) // Verify mock interactions
}

func TestTokenService_ValidateToken_InvalidSignature(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()

	// Create a token with an *invalid* signature
	invalidClaims := jwt.MapClaims{
		"sub": "invalid-user",
		"exp": time.Now().Add(time.Hour).Unix(),
		"jti": uuid.New().String(),
	}
	invalidToken := jwt.NewWithClaims(jwt.SigningMethodHS256, invalidClaims)
	invalidTokenString, _ := invalidToken.SignedString([]byte("wrong-secret")) // WRONG SECRET!

	// No mock setup for IsTokenRevoked needed - it should *not* be called

	// Call ValidateToken
	_, err := tokenService.ValidateToken(ctx, invalidTokenString)

	// Assertions: We *expect* an error due to the invalid signature
	assert.Error(t, err)
	assert.ErrorIs(t, err, jwt.ErrSignatureInvalid) // Check for *specific* error

	mockRepo.AssertExpectations(t) // No calls expected, but good practice to include
}

func TestTokenService_ValidateToken_Expired(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()

	// Create an *expired* token
	expiredClaims := jwt.MapClaims{
		"sub": "some-user",
		"exp": time.Now().Add(-time.Hour).Unix(), // Expired one hour ago!
		"jti": uuid.New().String(),
	}
	expiredToken := jwt.NewWithClaims(jwt.SigningMethodHS256, expiredClaims)
	expiredTokenString, _ := expiredToken.SignedString([]byte("test-secret"))

	// No mock setup for IsTokenRevoked needed - it should *not* be called

	// Call ValidateToken
	_, err := tokenService.ValidateToken(ctx, expiredTokenString)

	// Assertions: We *expect* an error due to expiration
	assert.Error(t, err)
	assert.ErrorIs(t, err, jwt.ErrTokenExpired) // Check for *specific* error

	mockRepo.AssertExpectations(t)
}

func TestTokenService_ValidateToken_Revoked(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()
	userID := uuid.New() // Consistent user ID

	// Create a token that's otherwise valid, but we'll *pretend* it's revoked
	revokedJti := uuid.New().String() // The JTI we'll "revoke"
	claimsMap := jwt.MapClaims{
		"sub": userID.String(),                  // Use consistent user ID
		"exp": time.Now().Add(time.Hour).Unix(), // Not expired
		"jti": revokedJti,                       // Set the JTI
	}
	revokedToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claimsMap)
	revokedTokenString, _ := revokedToken.SignedString([]byte("test-secret"))

	// Configure the mock:  IsTokenRevoked *will* be called with the revoked JTI
	mockRepo.On("IsTokenRevoked", ctx, revokedJti).Return(true, nil)

	// Call ValidateToken
	_, err := tokenService.ValidateToken(ctx, revokedTokenString)

	// Assertions: We *expect* a "token has been revoked" error
	assert.Error(t, err)
	assert.EqualError(t, err, "token has been revoked") // Check for *specific* error

	mockRepo.AssertExpectations(t)
}


===== File: ./internal/service/password_checker.go =====
package service

import "golang.org/x/crypto/bcrypt"

// PasswordChecker interface defines the contract for password checking.
type PasswordChecker interface {
	CheckPasswordHash(password, hash string) bool
}

// bcryptPasswordChecker is a concrete implementation using bcrypt.
type bcryptPasswordChecker struct{}

// CheckPasswordHash implements the PasswordChecker interface using bcrypt.
func (b *bcryptPasswordChecker) CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

// NewBcryptPasswordChecker creates a new instance of bcryptPasswordChecker.
func NewBcryptPasswordChecker() *bcryptPasswordChecker {
	return &bcryptPasswordChecker{}
}


===== File: ./internal/service/user_service.go =====
package service

import (
	"context"
	"fmt"

	"github.com/tomascosta29/CostaAuth/internal/model"
	"github.com/tomascosta29/CostaAuth/internal/repository"
	"golang.org/x/crypto/bcrypt"
)

type UserServiceInterface interface {
	RegisterUser(ctx context.Context, req *model.RegisterRequest) (*model.User, error)
	LoginUser(ctx context.Context, req *model.LoginRequest) (*model.User, error)
	HashPassword(password string) (string, error) // keep this here
}

type UserService struct {
	userRepo        repository.UserRepository
	passwordChecker PasswordChecker // Add the dependency
}

// Update the constructor to accept the PasswordChecker
func NewUserService(userRepo repository.UserRepository, passwordChecker PasswordChecker) *UserService {
	return &UserService{userRepo: userRepo, passwordChecker: passwordChecker}
}

// ... (RegisterUser function - see below for changes) ...
func (s *UserService) RegisterUser(ctx context.Context, req *model.RegisterRequest) (*model.User, error) {
	// Check if the username or email already exists
	existingUser, err := s.userRepo.GetUserByUsername(ctx, req.Username)
	if err != nil {
		return nil, err
	}
	if existingUser != nil {
		return nil, fmt.Errorf("username already exists")
	}
	existingUser, err = s.userRepo.GetUserByEmail(ctx, req.Email) // add GetUserByEmail to repo interface + impl
	if err != nil {
		return nil, err
	}
	if existingUser != nil {
		return nil, fmt.Errorf("email already exists")
	}

	// Hash the password
	hashedPassword, err := s.HashPassword(req.Password)
	if err != nil {
		return nil, err
	}

	// Create the user
	newUser := &model.User{
		Username:     req.Username,
		Email:        req.Email,
		PasswordHash: hashedPassword,
		IsActive:     true, // Or false, if you require email verification
	}

	err = s.userRepo.CreateUser(ctx, newUser)
	if err != nil {
		return nil, err
	}

	return newUser, nil
}

func (s *UserService) LoginUser(ctx context.Context, req *model.LoginRequest) (*model.User, error) {
	user, err := s.userRepo.GetUserByUsername(ctx, req.Username)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Use the injected PasswordChecker
	if !s.passwordChecker.CheckPasswordHash(req.Password, user.PasswordHash) {
		return nil, fmt.Errorf("invalid credentials")
	}

	return user, nil
}

// HashPassword hashes a password using bcrypt
func (s *UserService) HashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedPassword), nil
}


===== File: ./internal/service/user_service_test.go =====
package service

import (
	"context"
	"errors"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/tomascosta29/CostaAuth/internal/model"
)

// Mock UserRepository for testing the service
type MockUserRepository struct {
	mock.Mock
}

func (m *MockUserRepository) CreateUser(ctx context.Context, user *model.User) error {
	args := m.Called(ctx, user)
	return args.Error(0)
}

func (m *MockUserRepository) GetUserByUsername(ctx context.Context, username string) (*model.User, error) {
	args := m.Called(ctx, username)
	if args.Get(0) == nil { // important for nil returns
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserRepository) GetUserByID(ctx context.Context, id uuid.UUID) (*model.User, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil { // important for nil returns
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserRepository) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	args := m.Called(ctx, email)
	if args.Get(0) == nil { // important for nil returns
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

// Mock PasswordChecker
type MockPasswordChecker struct {
	mock.Mock
}

func (m *MockPasswordChecker) CheckPasswordHash(password, hash string) bool {
	args := m.Called(password, hash)
	return args.Bool(0)
}

func TestUserService_RegisterUser(t *testing.T) {
	mockRepo := new(MockUserRepository)
	mockChecker := new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService := NewUserService(mockRepo, mockChecker) // Inject the dependency
	ctx := context.Background()

	// Test case: Successful registration
	req := &model.RegisterRequest{
		Username: "newuser",
		Email:    "newuser@example.com",
		Password: "password123",
	}
	// Mock GetUserByUsername to return nil, nil (user not found)
	mockRepo.On("GetUserByUsername", ctx, req.Username).Return((*model.User)(nil), nil)
	mockRepo.On("GetUserByEmail", ctx, req.Email).Return((*model.User)(nil), nil)

	// Mock CreateUser to return nil (no error)
	mockRepo.On("CreateUser", ctx, mock.AnythingOfType("*model.User")).Return(nil)

	user, err := userService.RegisterUser(ctx, req)
	assert.NoError(t, err)
	assert.NotNil(t, user)
	assert.Equal(t, req.Username, user.Username)
	assert.NotEmpty(t, user.PasswordHash) // Check that password was hashed

	// Test case: Username already exists
	mockRepo = new(MockUserRepository) // Reset mock for next scenario
	mockChecker = new(MockPasswordChecker)
	userService = NewUserService(mockRepo, mockChecker)

	existingUser := &model.User{Username: "existinguser"}
	mockRepo.On("GetUserByUsername", ctx, "existinguser").Return(existingUser, nil)

	req = &model.RegisterRequest{
		Username: "existinguser",
		Email:    "existing@example.com",
		Password: "password123",
	}
	_, err = userService.RegisterUser(ctx, req)
	assert.Error(t, err)
	assert.EqualError(t, err, "username already exists") // check for specific error

	// Test case: Email already exists
	mockRepo = new(MockUserRepository) // Reset mock for next scenario
	mockChecker = new(MockPasswordChecker)
	userService = NewUserService(mockRepo, mockChecker)

	existingUser = &model.User{Email: "existing@email.com"}
	mockRepo.On("GetUserByUsername", ctx, "newuser").Return((*model.User)(nil), nil)
	mockRepo.On("GetUserByEmail", ctx, "existing@email.com").Return(existingUser, nil)
	req = &model.RegisterRequest{
		Username: "newuser",
		Email:    "existing@email.com",
		Password: "password123",
	}
	_, err = userService.RegisterUser(ctx, req)
	assert.Error(t, err)
	assert.EqualError(t, err, "email already exists") // check for specific error

	// Test case: CreateUser returns an error
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)
	userService = NewUserService(mockRepo, mockChecker)

	mockRepo.On("GetUserByUsername", ctx, "newuser").Return((*model.User)(nil), nil)          // User not found
	mockRepo.On("GetUserByEmail", ctx, "newuser@example.com").Return((*model.User)(nil), nil) // User not found

	mockRepo.On("CreateUser", ctx, mock.AnythingOfType("*model.User")).Return(errors.New("database error"))

	req = &model.RegisterRequest{Username: "newuser", Email: "newuser@example.com", Password: "password123"}
	_, err = userService.RegisterUser(ctx, req)
	assert.Error(t, err) // Check for any error

	mockRepo.AssertExpectations(t) // Ensure all expected calls were made
	mockChecker.AssertExpectations(t)
}

func TestUserService_LoginUser(t *testing.T) {
	mockRepo := new(MockUserRepository)
	mockChecker := new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService := NewUserService(mockRepo, mockChecker) // Inject *both* mocks
	ctx := context.Background()

	// --- Test case: Successful login ---
	req := &model.LoginRequest{Username: "testuser", Password: "password123"}
	existingUser := &model.User{
		ID:           uuid.New(),
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "$2a$10$somehashedpassword", // Example bcrypt hash
		IsActive:     true,
	}
	mockRepo.On("GetUserByUsername", ctx, "testuser").Return(existingUser, nil)
	mockChecker.On("CheckPasswordHash", "password123", "$2a$10$somehashedpassword").Return(true) // Mock the checker

	user, err := userService.LoginUser(ctx, req)
	assert.NoError(t, err)
	assert.NotNil(t, user)
	assert.Equal(t, existingUser, user)

	// Reset Mocks
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService = NewUserService(mockRepo, mockChecker) // Inject *both* mocks

	// --- Test case: Wrong password ---
	req = &model.LoginRequest{Username: "testuser", Password: "wrongpassword"}
	mockRepo.On("GetUserByUsername", ctx, "testuser").Return(existingUser, nil)
	mockChecker.On("CheckPasswordHash", "wrongpassword", "$2a$10$somehashedpassword").Return(false) // Mock to fail

	user, err = userService.LoginUser(ctx, req)
	assert.Error(t, err)
	assert.Nil(t, user)
	assert.EqualError(t, err, "invalid credentials")

	// --- Test case: User not found ---
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService = NewUserService(mockRepo, mockChecker) // Inject *both* mocks
	mockRepo.On("GetUserByUsername", ctx, "nonexistentuser").Return((*model.User)(nil), nil)

	req = &model.LoginRequest{Username: "nonexistentuser", Password: "password123"}
	_, err = userService.LoginUser(ctx, req)
	assert.Error(t, err)
	assert.Nil(t, user)
	assert.EqualError(t, err, "invalid credentials")

	// --- Test case: GetUserByUsername returns an error ---
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService = NewUserService(mockRepo, mockChecker) // Inject *both* mocks

	mockRepo.On("GetUserByUsername", ctx, "erroruser").Return((*model.User)(nil), errors.New("database error"))
	req = &model.LoginRequest{Username: "erroruser", Password: "password123"}
	_, err = userService.LoginUser(ctx, req)
	assert.Error(t, err)
	assert.Nil(t, user)

	mockRepo.AssertExpectations(t)
	mockChecker.AssertExpectations(t)
}

func TestUserService_HashPassword(t *testing.T) {
	mockRepo := new(MockUserRepository)
	mockChecker := new(MockPasswordChecker)
	userService := NewUserService(mockRepo, mockChecker)

	password := "password123"
	hashedPassword, err := userService.HashPassword(password)
	assert.NoError(t, err)
	assert.NotEmpty(t, hashedPassword)           // Check that hash is not empty
	assert.NotEqual(t, password, hashedPassword) // Check that hash is different from the original

	mockRepo.AssertExpectations(t)
	mockChecker.AssertExpectations(t)
}


===== File: ./internal/security/password.go =====
package security

import "golang.org/x/crypto/bcrypt"

// HashPassword hashes a password using bcrypt
func HashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedPassword), nil
}

// CheckPasswordHash compares a password with its hash
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}


===== File: ./source.go =====
===== File: ./cmd/costa-auth/main.go =====
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	"github.com/tomascosta29/CostaAuth/internal/app"
	"github.com/tomascosta29/CostaAuth/internal/config"
	"github.com/tomascosta29/CostaAuth/internal/handler"
	"github.com/tomascosta29/CostaAuth/internal/repository"
	"github.com/tomascosta29/CostaAuth/internal/service"
)

func main() {
	// Load configuration
	cfg, err := config.LoadConfig(".env")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	// Initialize database connections
	userRepo, err := repository.NewSQLiteUserRepository("auth.db") // Use SQLite
	if err != nil {
		log.Fatal("failed to connect to SQLite", err)
	}

	// Choose TokenRepository implementation based on environment variable
	var tokenRepo repository.TokenRepository
	if cfg.TokenStore == "redis" {
		tokenRepo, err = repository.NewRedisTokenRepository(cfg.RedisAddress, cfg.RedisPassword)
		if err != nil {
			log.Fatal("Failed to create Redis client:", err)
		}
	} else if cfg.TokenStore == "inmemory" {
		tokenRepo = repository.NewInMemoryTokenRepository()
	} else {
		log.Fatalf("Invalid TOKEN_STORE environment variable: %s. Must be 'redis' or 'inmemory'.", cfg.TokenStore)
	}

	// Create the real bcryptPasswordChecker
	passwordChecker := service.NewBcryptPasswordChecker()

	// Initialize services
	userService := service.NewUserService(userRepo, passwordChecker)          // Inject passwordChecker
	tokenService := service.NewTokenService(tokenRepo, []byte(cfg.JWTSecret)) // Use selected tokenRepo

	// Initialize handlers
	authHandler := handler.NewAuthHandler(userService, tokenService)

	// Create router and register routes
	r := mux.NewRouter()
	authHandler.RegisterRoutes(r)

	// Create a server
	server := &http.Server{
		Addr:         ":" + cfg.Port,
		Handler:      r,
		ReadTimeout:  10 * time.Second,
		WriteTimeout: 10 * time.Second,
	}

	// --- mTLS Setup (Conditional) ---
	if cfg.MTLSEnabled {
		tlsConfig, err := app.SetupTLSConfig(cfg)
		if err != nil {
			log.Fatal("Failed to setup TLS config:", err)
		}
		server.TLSConfig = tlsConfig
	}

	// Graceful shutdown setup
	idleConnsClosed := make(chan struct{})
	go func() {
		sigint := make(chan os.Signal, 1)
		signal.Notify(sigint, os.Interrupt, syscall.SIGTERM)
		<-sigint

		// We received an interrupt signal, shut down.
		log.Println("Shutting down server...")
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		if err := server.Shutdown(ctx); err != nil {
			// Error from closing listeners, or context timeout:
			log.Printf("HTTP server Shutdown: %v", err)
		}
		close(idleConnsClosed)
	}()

	// Start the server (with or without TLS)
	fmt.Printf("Starting server on port %s (mTLS: %t)\n", cfg.Port, cfg.MTLSEnabled)
	if cfg.MTLSEnabled {
		// Start with TLS
		// Use ListenAndServeTLS with empty strings for cert and key,
		// because they are already loaded in server.TLSConfig
		err = server.ListenAndServeTLS("", "") // Use ListenAndServeTLS
	} else {
		// Start without TLS
		err = server.ListenAndServe()
	}

	if err != http.ErrServerClosed {
		log.Fatalf("HTTP server ListenAndServe: %v", err)
	}

	<-idleConnsClosed
	log.Println("Server gracefully stopped")
}


===== File: ./internal/app/auth.go =====
package app

// could have your main app struct


===== File: ./internal/app/errors.go =====
package app

// custom error types go here


===== File: ./internal/app/tls.go =====
package app

import (
	"crypto/tls"
	"crypto/x509"
	"fmt"
	"os"

	"github.com/tomascosta29/CostaAuth/internal/config"
)

// SetupTLSConfig creates a *tls.Config for mTLS.
func SetupTLSConfig(cfg *config.Config) (*tls.Config, error) {
	// Load server certificate and private key
	cert, err := tls.LoadX509KeyPair(cfg.ServerCertFile, cfg.ServerKeyFile)
	if err != nil {
		return nil, fmt.Errorf("failed to load server key pair: %w", err)
	}

	// Load CA certificate (for client certificate verification)
	caCert, err := os.ReadFile(cfg.CACertFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read CA certificate: %w", err)
	}

	// Create a certificate pool and add the CA certificate
	caCertPool := x509.NewCertPool()
	if ok := caCertPool.AppendCertsFromPEM(caCert); !ok {
		return nil, fmt.Errorf("failed to append CA certificate to pool")
	}

	// Create the TLS configuration
	tlsConfig := &tls.Config{
		Certificates: []tls.Certificate{cert},        // Server's certificate
		ClientAuth:   tls.RequireAndVerifyClientCert, // Require and verify client certs
		ClientCAs:    caCertPool,                     // CA pool for client verification
		MinVersion:   tls.VersionTLS12,               // Good practice: Enforce TLS 1.2 or higher
	}

	return tlsConfig, nil
}


===== File: ./internal/config/config.go =====
package config

import (
	"fmt"
	"os"

	"github.com/joho/godotenv"
)

type Config struct {
	Port           string
	RedisAddress   string
	RedisPassword  string
	JWTSecret      string
	TokenStore     string
	MTLSEnabled    bool   // mTLS enabled flag
	ServerCertFile string // Path to server cert
	ServerKeyFile  string // Path to server key
	CACertFile     string // Path to CA cert
}

func LoadConfig(envPath string) (*Config, error) {
	_ = godotenv.Load(envPath)

	cfg := &Config{
		Port:           os.Getenv("PORT"),
		RedisAddress:   os.Getenv("REDIS_ADDRESS"),
		RedisPassword:  os.Getenv("REDIS_PASSWORD"),
		JWTSecret:      os.Getenv("JWT_SECRET"),
		TokenStore:     os.Getenv("TOKEN_STORE"),
		MTLSEnabled:    os.Getenv("MTLS_ENABLED") == "true", // Convert to bool
		ServerCertFile: os.Getenv("SERVER_CERT_FILE"),
		ServerKeyFile:  os.Getenv("SERVER_KEY_FILE"),
		CACertFile:     os.Getenv("CA_CERT_FILE"),
	}

	if cfg.TokenStore == "" {
		return nil, fmt.Errorf("TOKEN_STORE environment variable must be set ('redis' or 'inmemory')")
	}

	if cfg.MTLSEnabled {
		if cfg.ServerCertFile == "" || cfg.ServerKeyFile == "" || cfg.CACertFile == "" {
			return nil, fmt.Errorf("MTLS_ENABLED is true, but SERVER_CERT_FILE, SERVER_KEY_FILE, and CA_CERT_FILE are not all set")
		}
	}

	return cfg, nil
}


===== File: ./internal/handler/auth_handler.go =====
package handler

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/tomascosta29/CostaAuth/internal/model"
	"github.com/tomascosta29/CostaAuth/internal/service"
)

type AuthHandler struct {
	userService  service.UserServiceInterface  // Use the interface
	tokenService service.TokenServiceInterface // Use the interface
}

func NewAuthHandler(userService service.UserServiceInterface, tokenService service.TokenServiceInterface) *AuthHandler {
	return &AuthHandler{userService: userService, tokenService: tokenService}
}

func (h *AuthHandler) RegisterRoutes(r *mux.Router) {
	r.HandleFunc("/auth/register", h.RegisterHandler).Methods("POST")
	r.HandleFunc("/auth/login", h.LoginHandler).Methods("POST")
	r.HandleFunc("/auth/refresh", h.RefreshHandler).Methods("POST")
	r.HandleFunc("/auth/logout", h.LogoutHandler).Methods("POST")
	r.HandleFunc("/auth/validate", h.ValidateTokenHandler).Methods("GET")
}

func (h *AuthHandler) RegisterHandler(w http.ResponseWriter, r *http.Request) {
	var req model.RegisterRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	_, err := h.userService.RegisterUser(r.Context(), &req)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest) // Or a different status code
		return
	}

	w.WriteHeader(http.StatusCreated) // 201 Created
	fmt.Fprintln(w, "User registered successfully")
}

func (h *AuthHandler) LoginHandler(w http.ResponseWriter, r *http.Request) {
	var req model.LoginRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	user, err := h.userService.LoginUser(r.Context(), &req)
	if err != nil {
		http.Error(w, err.Error(), http.StatusUnauthorized)
		return
	}

	token, err := h.tokenService.GenerateToken(r.Context(), user.ID)
	if err != nil {
		http.Error(w, "Failed to generate token", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"token": token})
}

func (h *AuthHandler) RefreshHandler(w http.ResponseWriter, r *http.Request) {
	var req model.RefreshRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// in a real-world scenario you would retrieve the refresh token claims
	// here for simplicity's sake, and since its a mock, its not really implemented
	// so we just return a new token.
	// Refresh Token logic would include validating the Refresh token,
	// checking if its blacklisted, and issueing a new access token
	// (and potentially, a new refresh token)

	userID, _ := uuid.NewUUID() // Normally, extract user ID from refresh token
	accessToken, err := h.tokenService.GenerateToken(r.Context(), userID)
	if err != nil {
		http.Error(w, "Failed to generate access token", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"access_token": accessToken})
}

func (h *AuthHandler) ValidateTokenHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := r.Header.Get("Authorization")

	if authHeader == "" {
		http.Error(w, "Authorization header required", http.StatusUnauthorized)
		return
	}
	// JWT has "Bearer " prefix
	tokenString := authHeader[len("Bearer "):]

	claims, err := h.tokenService.ValidateToken(r.Context(), tokenString)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid token: %v", err), http.StatusUnauthorized)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(claims)
}

func (h *AuthHandler) LogoutHandler(w http.ResponseWriter, r *http.Request) {
	authHeader := r.Header.Get("Authorization")
	if authHeader == "" {
		http.Error(w, "Authorization header required", http.StatusUnauthorized)
		return
	}
	tokenString := authHeader[len("Bearer "):]
	err := h.tokenService.RevokeToken(r.Context(), tokenString)
	if err != nil {
		http.Error(w, fmt.Sprintf("could not log out: %v", err), http.StatusUnauthorized)
	}
	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "Logged out successfully")
}


===== File: ./internal/handler/auth_handler_test.go =====
package handler

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/tomascosta29/CostaAuth/internal/model"
)

type MockUserService struct {
	mock.Mock
}

func (m *MockUserService) RegisterUser(ctx context.Context, req *model.RegisterRequest) (*model.User, error) {
	args := m.Called(ctx, req)
	if args.Get(0) == nil { // handle nil case
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserService) LoginUser(ctx context.Context, req *model.LoginRequest) (*model.User, error) {
	args := m.Called(ctx, req)
	if args.Get(0) == nil { // handle nil case
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserService) HashPassword(password string) (string, error) {
	args := m.Called(password)
	return args.String(0), args.Error(1)
}

// CheckPasswordHash compares a password with its hash
func (m *MockUserService) CheckPasswordHash(password, hash string) bool {
	args := m.Called(password, hash)
	return args.Bool(0)
}

type MockTokenService struct {
	mock.Mock
}

func (m *MockTokenService) GenerateToken(ctx context.Context, userID uuid.UUID) (string, error) {
	args := m.Called(ctx, userID)
	return args.String(0), args.Error(1)
}

func (m *MockTokenService) ValidateToken(ctx context.Context, tokenString string) (jwt.MapClaims, error) {
	args := m.Called(ctx, tokenString)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(jwt.MapClaims), args.Error(1) // cast to map
}

func (m *MockTokenService) RevokeToken(ctx context.Context, tokenString string) error {
	args := m.Called(ctx, tokenString)
	return args.Error(0)
}

func TestAuthHandler_RegisterHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Successful registration
	reqBody := `{"username": "testuser", "email": "test@example.com", "password": "password123"}`
	req, _ := http.NewRequest("POST", "/auth/register", bytes.NewBufferString(reqBody))
	recorder := httptest.NewRecorder()
	// Mock behavior for successful registration
	mockUserService.On("RegisterUser", mock.Anything, mock.AnythingOfType("*model.RegisterRequest")).Return(&model.User{}, nil)

	handler.RegisterHandler(recorder, req)

	assert.Equal(t, http.StatusCreated, recorder.Code)
	assert.Equal(t, "User registered successfully\n", recorder.Body.String())

	// Reset the mock for the next test case!  This is important.
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Invalid request body
	req, _ = http.NewRequest("POST", "/auth/register", bytes.NewBufferString("invalid json"))
	recorder = httptest.NewRecorder()

	handler.RegisterHandler(recorder, req)
	assert.Equal(t, http.StatusBadRequest, recorder.Code)

	// Reset the mock for the next test case
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Registration error (e.g., username already exists)
	req, _ = http.NewRequest("POST", "/auth/register", bytes.NewBufferString(reqBody)) // valid request
	recorder = httptest.NewRecorder()

	// Mock behavior for registration error
	mockUserService.On("RegisterUser", mock.Anything, mock.AnythingOfType("*model.RegisterRequest")).Return(nil, errors.New("some error"))

	handler.RegisterHandler(recorder, req)
	assert.Equal(t, http.StatusBadRequest, recorder.Code) // expect 400

	// The mock expectations must be asserted *AFTER* the handler call that uses the mock.
	mockUserService.AssertExpectations(t)
	mockTokenService.AssertExpectations(t)
}

func TestAuthHandler_LoginHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Successful login
	reqBody := `{"username": "testuser", "password": "password123"}`
	req, _ := http.NewRequest("POST", "/auth/login", bytes.NewBufferString(reqBody))
	recorder := httptest.NewRecorder()
	mockUserService.On("LoginUser", mock.Anything, mock.AnythingOfType("*model.LoginRequest")).Return(&model.User{ID: uuid.New()}, nil)
	mockTokenService.On("GenerateToken", mock.Anything, mock.AnythingOfType("uuid.UUID")).Return("testtoken", nil)

	handler.LoginHandler(recorder, req)

	assert.Equal(t, http.StatusOK, recorder.Code)
	var response map[string]string
	json.Unmarshal(recorder.Body.Bytes(), &response)
	assert.Equal(t, "testtoken", response["token"])

	// Reset mocks
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Invalid request body
	req, _ = http.NewRequest("POST", "/auth/login", bytes.NewBufferString("invalid json"))
	recorder = httptest.NewRecorder()

	handler.LoginHandler(recorder, req)
	assert.Equal(t, http.StatusBadRequest, recorder.Code)

	// Reset mocks
	mockUserService = new(MockUserService)
	mockTokenService = new(MockTokenService)
	handler = NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Login error (e.g., user not found)
	req, _ = http.NewRequest("POST", "/auth/login", bytes.NewBufferString(reqBody)) // valid request
	recorder = httptest.NewRecorder()

	mockUserService.On("LoginUser", mock.Anything, mock.AnythingOfType("*model.LoginRequest")).Return(nil, errors.New("some error"))

	handler.LoginHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code) // expect 401

	// Assert expectations *after* the handler call and assertions.
	mockUserService.AssertExpectations(t)
	mockTokenService.AssertExpectations(t)
}

func TestAuthHandler_ValidateTokenHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)

	// Test case: Successful validation
	tokenString := "valid-token" // dummy
	req, _ := http.NewRequest("GET", "/auth/validate", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)
	recorder := httptest.NewRecorder()

	mockTokenService.On("ValidateToken", mock.Anything, tokenString).Return(jwt.MapClaims{"sub": "testuser"}, nil)

	handler.ValidateTokenHandler(recorder, req)

	assert.Equal(t, http.StatusOK, recorder.Code)
	var response map[string]interface{}

	json.Unmarshal(recorder.Body.Bytes(), &response)
	assert.Equal(t, "testuser", response["sub"])

	// Test case: missing header
	req, _ = http.NewRequest("GET", "/auth/validate", nil)
	recorder = httptest.NewRecorder()
	handler.ValidateTokenHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)

	// Test case: Invalid token
	req, _ = http.NewRequest("GET", "/auth/validate", nil)
	req.Header.Set("Authorization", "Bearer invalid-token")
	recorder = httptest.NewRecorder()

	mockTokenService.On("ValidateToken", mock.Anything, "invalid-token").Return(nil, assert.AnError)

	handler.ValidateTokenHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)

	mockUserService.AssertExpectations(t)
	mockTokenService.AssertExpectations(t)
}

func TestAuthHandler_LogoutHandler(t *testing.T) {
	mockUserService := new(MockUserService)
	mockTokenService := new(MockTokenService)
	handler := NewAuthHandler(mockUserService, mockTokenService)
	tokenString := "valid-token" // dummy

	// Test case: Successful logout
	req, _ := http.NewRequest("POST", "/auth/logout", nil)
	req.Header.Set("Authorization", "Bearer "+tokenString)
	recorder := httptest.NewRecorder()
	mockTokenService.On("RevokeToken", mock.Anything, tokenString).Return(nil)

	handler.LogoutHandler(recorder, req)

	assert.Equal(t, http.StatusOK, recorder.Code)

	// Test case: missing header
	req, _ = http.NewRequest("POST", "/auth/logout", nil)
	recorder = httptest.NewRecorder()
	handler.LogoutHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)

	// Test case: Revoke token error
	req, _ = http.NewRequest("POST", "/auth/logout", nil)
	req.Header.Set("Authorization", "Bearer invalid-token")
	recorder = httptest.NewRecorder()
	mockTokenService.On("RevokeToken", mock.Anything, "invalid-token").Return(assert.AnError)
	handler.LogoutHandler(recorder, req)
	assert.Equal(t, http.StatusUnauthorized, recorder.Code)
	mockTokenService.AssertExpectations(t)
	mockUserService.AssertExpectations(t)
}


===== File: ./internal/handler/middleware.go =====
package handler

import (
	"fmt"
	"net/http"

	"github.com/tomascosta29/CostaAuth/internal/service"
)

// AuthMiddleware is a middleware function that checks for a valid JWT
func AuthMiddleware(tokenService *service.TokenService) func(next http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			authHeader := r.Header.Get("Authorization")
			if authHeader == "" {
				http.Error(w, "Authorization header required", http.StatusUnauthorized)
				return
			}

			// JWT has "Bearer " prefix
			tokenString := authHeader[len("Bearer "):]

			_, err := tokenService.ValidateToken(r.Context(), tokenString)
			if err != nil {
				http.Error(w, fmt.Sprintf("Invalid token: %v", err), http.StatusUnauthorized)
				return
			}

			// Token is valid, proceed to the next handler
			next.ServeHTTP(w, r)
		})
	}
}


===== File: ./internal/model/user.go =====
package model

import "github.com/google/uuid"

type User struct {
	ID           uuid.UUID `json:"id"`
	Username     string    `json:"username"`
	Email        string    `json:"email"`
	PasswordHash string    `json:"-"` // Don't serialize the password hash
	CreatedAt    int64     `json:"created_at"`
	UpdatedAt    int64     `json:"updated_at"`
	IsActive     bool      `json:"is_active"`
}


===== File: ./internal/model/token.go =====
package model

type Token struct {
	JTI   string `json:"jti"` // used for blacklisting
	Token string `json:"token"`
}


===== File: ./internal/model/request.go =====
package model

type LoginRequest struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type RegisterRequest struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type RefreshRequest struct {
	RefreshToken string `json:"refresh_token"`
}


===== File: ./internal/repository/user_repository.go =====
package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/tomascosta29/CostaAuth/internal/model"
)

type UserRepository interface {
	CreateUser(ctx context.Context, user *model.User) error
	GetUserByUsername(ctx context.Context, username string) (*model.User, error)
	GetUserByID(ctx context.Context, id uuid.UUID) (*model.User, error)
	GetUserByEmail(ctx context.Context, email string) (*model.User, error)
}


===== File: ./internal/repository/user_repository_sqlite.go =====
package repository

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/google/uuid"
	_ "github.com/mattn/go-sqlite3" // Import the SQLite driver
	"github.com/tomascosta29/CostaAuth/internal/model"
	// Import the SQLite driver
)

type SQLiteUserRepository struct {
	db *sql.DB
}

func NewSQLiteUserRepository(dbPath string) (*SQLiteUserRepository, error) {
	db, err := sql.Open("sqlite3", dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	// Ensure the database is properly closed on application exit.  Good practice.
	//  In a real app, you might want to handle graceful shutdowns more carefully.
	// go func() {
	// 	<-ctx.Done() //usually you have a ctx passed down to main
	// 	db.Close()
	// }()

	if err := db.Ping(); err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	// Create the users table if it doesn't exist
	if err := createUsersTable(db); err != nil {
		return nil, fmt.Errorf("failed to create users table: %w", err)
	}

	return &SQLiteUserRepository{db: db}, nil
}

func createUsersTable(db *sql.DB) error {
	createTableSQL := `
		CREATE TABLE IF NOT EXISTS users (
			id TEXT PRIMARY KEY,
			username TEXT NOT NULL UNIQUE,
			email TEXT NOT NULL UNIQUE,
			password_hash TEXT NOT NULL,
			created_at INTEGER NOT NULL,
			updated_at INTEGER NOT NULL,
			is_active INTEGER NOT NULL
		);
	`
	_, err := db.Exec(createTableSQL)
	return err
}

func (r *SQLiteUserRepository) CreateUser(ctx context.Context, user *model.User) error {
	user.ID = uuid.New()
	user.CreatedAt = time.Now().Unix()
	user.UpdatedAt = user.CreatedAt
	user.IsActive = true // default

	stmt, err := r.db.PrepareContext(ctx, "INSERT INTO users (id, username, email, password_hash, created_at, updated_at, is_active) VALUES (?, ?, ?, ?, ?, ?, ?)")
	if err != nil {
		return fmt.Errorf("failed to prepare insert statement: %w", err)
	}
	defer stmt.Close() // Important: Close the statement after use

	_, err = stmt.ExecContext(ctx, user.ID, user.Username, user.Email, user.PasswordHash, user.CreatedAt, user.UpdatedAt, user.IsActive)
	if err != nil {
		return fmt.Errorf("failed to insert user: %w", err)
	}

	return nil
}

func (r *SQLiteUserRepository) GetUserByUsername(ctx context.Context, username string) (*model.User, error) {
	user := &model.User{}
	row := r.db.QueryRowContext(ctx, "SELECT id, username, email, password_hash, created_at, updated_at, is_active FROM users WHERE username = ?", username)
	err := row.Scan(&user.ID, &user.Username, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt, &user.IsActive)
	if err == sql.ErrNoRows {
		return nil, nil // User not found, return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("failed to query user by username: %w", err)
	}
	return user, nil
}

func (r *SQLiteUserRepository) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	user := &model.User{}
	row := r.db.QueryRowContext(ctx, "SELECT id, username, email, password_hash, created_at, updated_at, is_active FROM users WHERE email = ?", email)
	err := row.Scan(&user.ID, &user.Username, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt, &user.IsActive)
	if err == sql.ErrNoRows {
		return nil, nil // User not found, return nil, nil
	} else if err != nil {
		return nil, fmt.Errorf("failed to query user by email: %w", err)
	}
	return user, nil
}

func (r *SQLiteUserRepository) GetUserByID(ctx context.Context, id uuid.UUID) (*model.User, error) {
	user := &model.User{}
	row := r.db.QueryRowContext(ctx, "SELECT id, username, email, password_hash, created_at, updated_at, is_active FROM users WHERE id = ?", id)
	err := row.Scan(&user.ID, &user.Username, &user.Email, &user.PasswordHash, &user.CreatedAt, &user.UpdatedAt, &user.IsActive)
	if err == sql.ErrNoRows {
		return nil, nil // User not found
	} else if err != nil {
		return nil, fmt.Errorf("failed to query user by ID: %w", err)
	}
	return user, nil
}


===== File: ./internal/repository/user_repository_sqlite_test.go =====
package repository

import (
	"context"
	"database/sql"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/tomascosta29/CostaAuth/internal/model"

	_ "github.com/mattn/go-sqlite3"
)

// Helper function to create a test database
func setupTestDB(t *testing.T) *sql.DB {
	db, err := sql.Open("sqlite3", ":memory:") // In-memory database
	require.NoError(t, err)

	err = createUsersTable(db)
	require.NoError(t, err)

	return db
}

func TestSQLiteUserRepository_CreateUser(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	user := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}

	err := repo.CreateUser(ctx, user)
	assert.NoError(t, err)
	assert.NotEqual(t, uuid.Nil, user.ID) // Check that ID was generated
}

func TestSQLiteUserRepository_GetUserByUsername(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	// Create a test user first
	existingUser := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}
	err := repo.CreateUser(ctx, existingUser)
	require.NoError(t, err)

	// Retrieve the user by username
	retrievedUser, err := repo.GetUserByUsername(ctx, "testuser")
	assert.NoError(t, err)
	assert.NotNil(t, retrievedUser)
	assert.Equal(t, existingUser.Username, retrievedUser.Username)
	assert.Equal(t, existingUser.Email, retrievedUser.Email)
	assert.Equal(t, existingUser.PasswordHash, retrievedUser.PasswordHash)

	// Test case: User not found
	retrievedUser, err = repo.GetUserByUsername(ctx, "nonexistentuser")
	assert.NoError(t, err) // No error should occur
	assert.Nil(t, retrievedUser)
}

func TestSQLiteUserRepository_GetUserByEmail(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	// Create a test user first
	existingUser := &model.User{
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}
	err := repo.CreateUser(ctx, existingUser)
	require.NoError(t, err)

	// Retrieve the user by email
	retrievedUser, err := repo.GetUserByEmail(ctx, "test@example.com")
	assert.NoError(t, err)
	assert.NotNil(t, retrievedUser)
	assert.Equal(t, existingUser.Username, retrievedUser.Username)

	// Test case: User not found
	retrievedUser, err = repo.GetUserByEmail(ctx, "nonexistentuser@email.com")
	assert.NoError(t, err)
	assert.Nil(t, retrievedUser)
}

func TestSQLiteUserRepository_GetUserByID(t *testing.T) {
	db := setupTestDB(t)
	defer db.Close()
	repo := &SQLiteUserRepository{db: db}
	ctx := context.Background()

	// Create a test user
	existingUser := &model.User{
		Username:     "testuser2",
		Email:        "test2@example.com",
		PasswordHash: "hashedpassword",
		IsActive:     true,
	}
	err := repo.CreateUser(ctx, existingUser)
	require.NoError(t, err)

	retrievedUser, err := repo.GetUserByID(ctx, existingUser.ID)
	assert.NoError(t, err)
	assert.NotNil(t, retrievedUser)
	assert.Equal(t, existingUser.ID, retrievedUser.ID)

	// Test case: User not found
	randomID := uuid.New()
	retrievedUser, err = repo.GetUserByID(ctx, randomID)
	assert.NoError(t, err)
	assert.Nil(t, retrievedUser)
}


===== File: ./internal/repository/token_repository_redis_test.go =====
package repository

import (
	"context"
	"testing"
	"time"

	"github.com/go-redis/redis/v8"
	"github.com/stretchr/testify/assert"
)

// Mock Redis for testing (can also use a real Redis instance if available)
type MockRedisClient struct {
	data map[string]string
}

func (m *MockRedisClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	if m.data == nil {
		m.data = make(map[string]string)
	}
	m.data[key] = value.(string) // Simple mock, assuming string values
	// Simulate expiration (simplified)
	if expiration > 0 {
		time.AfterFunc(expiration, func() {
			delete(m.data, key)
		})
	}
	return redis.NewStatusResult("", nil) // No error in mock
}

func (m *MockRedisClient) Get(ctx context.Context, key string) *redis.StringCmd {
	if m.data == nil {
		return redis.NewStringResult("", redis.Nil) // Key not found
	}
	val, ok := m.data[key]
	if !ok {
		return redis.NewStringResult("", redis.Nil)
	}
	return redis.NewStringResult(val, nil)
}

func (m *MockRedisClient) Ping(ctx context.Context) *redis.StatusCmd {
	return redis.NewStatusResult("PONG", nil) // No error in mock
}

func TestRedisTokenRepository_RevokeToken(t *testing.T) {
	mockClient := &MockRedisClient{}
	repo := &RedisTokenRepository{client: mockClient} // Use the mock
	ctx := context.Background()

	jti := "test-jti"
	expiration := time.Minute

	err := repo.RevokeToken(ctx, jti, expiration)
	assert.NoError(t, err)

	// Check if the token is revoked (using the mock)
	isRevoked, err := repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.True(t, isRevoked)

	// Wait longer than expiration
	time.Sleep(expiration + time.Millisecond*100) // add margin
	isRevoked, err = repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.False(t, isRevoked, "token should be expired")
}

func TestRedisTokenRepository_IsTokenRevoked(t *testing.T) {
	mockClient := &MockRedisClient{}
	repo := &RedisTokenRepository{client: mockClient}
	ctx := context.Background()

	jti := "another-test-jti"

	// Initially, the token should not be revoked
	isRevoked, err := repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.False(t, isRevoked)

	// Revoke the token
	err = repo.RevokeToken(ctx, jti, time.Minute)
	assert.NoError(t, err)

	// Now it should be revoked
	isRevoked, err = repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.True(t, isRevoked)
}

//For real integration test, you can use this (commented out) and replace MockRedisClient with a real client.
/*
func TestRedisTokenRepository_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test")
	}

	repo, err := NewRedisTokenRepository("localhost:6379", "") // Use a real Redis
    require.NoError(t, err)
	ctx := context.Background()

	jti := "integration-test-jti"
	expiration := time.Minute

	err = repo.RevokeToken(ctx, jti, expiration)
	assert.NoError(t, err)

	isRevoked, err := repo.IsTokenRevoked(ctx, jti)
	assert.NoError(t, err)
	assert.True(t, isRevoked)

    time.Sleep(expiration + time.Millisecond*100)
    isRevoked, err = repo.IsTokenRevoked(ctx, jti)
    assert.NoError(t, err)
    assert.False(t, isRevoked)
}
*/


===== File: ./internal/repository/token_repository_redis.go =====
package repository

import (
	"context"
	"time"

	"github.com/go-redis/redis/v8"
)

type RedisTokenRepository struct {
	client RedisClient
}

func NewRedisTokenRepository(address, password string) (*RedisTokenRepository, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     address,
		Password: password, // No password set
		DB:       0,        // Use default DB
	})

	_, err := client.Ping(context.Background()).Result()
	if err != nil {
		return nil, err
	}

	return &RedisTokenRepository{client: client}, nil
}

func (r *RedisTokenRepository) RevokeToken(ctx context.Context, jti string, expiration time.Duration) error {
	return r.client.Set(ctx, jti, "revoked", expiration).Err() // key, value, expiration
}

func (r *RedisTokenRepository) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	val, err := r.client.Get(ctx, jti).Result()
	if err == redis.Nil { // key not found == not blacklisted
		return false, nil
	} else if err != nil {
		return false, err
	}
	// If the key exists, the token is revoked
	return val == "revoked", nil
}


===== File: ./internal/repository/token_repository.go =====
package repository

import (
	"context"
	"time"

	"github.com/go-redis/redis/v8"
)

type TokenRepository interface {
	RevokeToken(ctx context.Context, jti string, expiration time.Duration) error
	IsTokenRevoked(ctx context.Context, jti string) (bool, error)
}

type RedisClient interface {
	Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd
	Get(ctx context.Context, key string) *redis.StringCmd
	Ping(ctx context.Context) *redis.StatusCmd
}


===== File: ./internal/repository/token_repository_inmemory.go =====
package repository

import (
	"context"
	"sync"
	"time"
)

// InMemoryTokenRepository is an in-memory implementation of TokenRepository.
// It's suitable for development, testing, and single-instance deployments.
type InMemoryTokenRepository struct {
	blacklist map[string]time.Time // Stores JTI -> Expiration Time
	mu        sync.RWMutex         // Protects concurrent access to the map
}

// NewInMemoryTokenRepository creates a new InMemoryTokenRepository.
func NewInMemoryTokenRepository() *InMemoryTokenRepository {
	return &InMemoryTokenRepository{
		blacklist: make(map[string]time.Time),
	}
}

// RevokeToken adds a token's JTI to the blacklist with an expiration time.
func (r *InMemoryTokenRepository) RevokeToken(ctx context.Context, jti string, expiration time.Duration) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	// Convert duration to expiration time
	expireAt := time.Now().Add(expiration)

	r.blacklist[jti] = expireAt

	// go routine to clean up
	go r.cleanup(jti, expiration)
	return nil
}

// IsTokenRevoked checks if a token's JTI is present in the blacklist.
func (r *InMemoryTokenRepository) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	expireAt, ok := r.blacklist[jti]
	if !ok {
		return false, nil // Not found, so not revoked
	}

	// Check if the token has expired
	if time.Now().After(expireAt) {
		// it is expired, so remove it
		return false, nil
	}

	return true, nil // Found, and not expired, so it's revoked
}

// cleanup removes the JTI from the map when it is expired
func (r *InMemoryTokenRepository) cleanup(jti string, expiration time.Duration) {
	time.Sleep(expiration)

	r.mu.Lock()
	defer r.mu.Unlock()
	delete(r.blacklist, jti)
}


===== File: ./internal/service/token_service.go =====
package service

import (
	"context"
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/tomascosta29/CostaAuth/internal/repository"
)

// Add this interface! Crucial for mocking the service for handler testing.
type TokenServiceInterface interface {
	GenerateToken(ctx context.Context, userID uuid.UUID) (string, error)
	ValidateToken(ctx context.Context, tokenString string) (jwt.MapClaims, error)
	RevokeToken(ctx context.Context, tokenString string) error
}

type TokenService struct {
	tokenRepo repository.TokenRepository
	jwtSecret []byte
}

func NewTokenService(tokenRepo repository.TokenRepository, jwtSecret []byte) *TokenService {
	return &TokenService{tokenRepo: tokenRepo, jwtSecret: jwtSecret}
}

// GenerateToken generates a new JWT
func (s *TokenService) GenerateToken(ctx context.Context, userID uuid.UUID) (string, error) {
	// Create the Claims
	claims := jwt.MapClaims{
		"sub": userID.String(),
		"iat": time.Now().Unix(),
		"exp": time.Now().Add(time.Hour * 1).Unix(), // 1-hour expiration
		"jti": uuid.New().String(),                  // Unique JWT ID
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	ss, err := token.SignedString(s.jwtSecret)
	return ss, err
}

// ValidateToken validates a JWT and returns the claims if valid
func (s *TokenService) ValidateToken(ctx context.Context, tokenString string) (jwt.MapClaims, error) {
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return s.jwtSecret, nil
	})
	if err != nil {
		return nil, err
	}

	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		// Check if the token is revoked
		jti, ok := claims["jti"].(string) // extract jti
		if !ok {
			return nil, fmt.Errorf("invalid token: missing jti")
		}
		isRevoked, err := s.tokenRepo.IsTokenRevoked(ctx, jti) // check if blacklisted
		if err != nil {
			return nil, fmt.Errorf("error checking token revocation status: %v", err)
		}
		if isRevoked {
			return nil, fmt.Errorf("token has been revoked")
		}

		return claims, nil
	} else {
		return nil, fmt.Errorf("invalid token")
	}
}

func (s *TokenService) RevokeToken(ctx context.Context, tokenString string) error {
	claims, err := s.ValidateToken(ctx, tokenString) // validate first
	if err != nil {
		return err
	}
	jti, ok := claims["jti"].(string) // extract jti
	if !ok {
		return fmt.Errorf("invalid token: missing jti")
	}
	exp, ok := claims["exp"].(float64)
	if !ok {
		return fmt.Errorf("invalid token: missing expiration")
	}
	expirationTime := time.Unix(int64(exp), 0)
	durationUntilExpiration := time.Until(expirationTime)

	return s.tokenRepo.RevokeToken(ctx, jti, durationUntilExpiration)
}


===== File: ./internal/service/token_service_test.go =====
package service

import (
	"context"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// --- Mock TokenRepository ---

// MockTokenRepository is a mock implementation of the TokenRepository interface.
type MockTokenRepository struct {
	mock.Mock // Use testify/mock for easy mocking
}

// RevokeToken is the mock implementation for RevokeToken.
func (m *MockTokenRepository) RevokeToken(ctx context.Context, jti string, expiration time.Duration) error {
	args := m.Called(ctx, jti, expiration) // Record the call
	return args.Error(0)                   // Return configured error (or nil)
}

// IsTokenRevoked is the mock implementation for IsTokenRevoked.
func (m *MockTokenRepository) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	args := m.Called(ctx, jti)         // Record the call
	return args.Bool(0), args.Error(1) // Return configured values (bool and error)
}

// --- Test Cases ---

func TestTokenService_GenerateToken(t *testing.T) {
	mockRepo := new(MockTokenRepository)                             // Create an instance of our mock
	tokenService := NewTokenService(mockRepo, []byte("test-secret")) // Inject the mock
	ctx := context.Background()
	userID := uuid.New()

	tokenString, err := tokenService.GenerateToken(ctx, userID)

	assert.NoError(t, err)          // Assert no error during generation
	assert.NotEmpty(t, tokenString) // Assert token string is not empty

	// Basic parsing to check structure (optional, but good for sanity)
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		return []byte("test-secret"), nil // Provide the signing key
	})
	assert.NoError(t, err)
	assert.True(t, token.Valid)

	claims, ok := token.Claims.(jwt.MapClaims)
	assert.True(t, ok)
	assert.Equal(t, userID.String(), claims["sub"]) // Check subject claim

	mockRepo.AssertExpectations(t) // Ensure mock was used as expected (it wasn't, but good practice)
}

func TestTokenService_ValidateToken_Valid(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()
	userID := uuid.New()

	// Generate a valid token (we'll use the *real* GenerateToken for this)
	validTokenString, err := tokenService.GenerateToken(ctx, userID)
	assert.NoError(t, err)

	// Configure the mock: IsTokenRevoked should return false (not revoked)
	mockRepo.On("IsTokenRevoked", ctx, mock.AnythingOfType("string")).Return(false, nil)

	// Call ValidateToken
	claims, err := tokenService.ValidateToken(ctx, validTokenString)

	// Assertions
	assert.NoError(t, err)                          // No error should occur
	assert.NotNil(t, claims)                        // Claims should be returned
	assert.Equal(t, userID.String(), claims["sub"]) // Check the subject

	mockRepo.AssertExpectations(t) // Verify mock interactions
}

func TestTokenService_ValidateToken_InvalidSignature(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()

	// Create a token with an *invalid* signature
	invalidClaims := jwt.MapClaims{
		"sub": "invalid-user",
		"exp": time.Now().Add(time.Hour).Unix(),
		"jti": uuid.New().String(),
	}
	invalidToken := jwt.NewWithClaims(jwt.SigningMethodHS256, invalidClaims)
	invalidTokenString, _ := invalidToken.SignedString([]byte("wrong-secret")) // WRONG SECRET!

	// No mock setup for IsTokenRevoked needed - it should *not* be called

	// Call ValidateToken
	_, err := tokenService.ValidateToken(ctx, invalidTokenString)

	// Assertions: We *expect* an error due to the invalid signature
	assert.Error(t, err)
	assert.ErrorIs(t, err, jwt.ErrSignatureInvalid) // Check for *specific* error

	mockRepo.AssertExpectations(t) // No calls expected, but good practice to include
}

func TestTokenService_ValidateToken_Expired(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()

	// Create an *expired* token
	expiredClaims := jwt.MapClaims{
		"sub": "some-user",
		"exp": time.Now().Add(-time.Hour).Unix(), // Expired one hour ago!
		"jti": uuid.New().String(),
	}
	expiredToken := jwt.NewWithClaims(jwt.SigningMethodHS256, expiredClaims)
	expiredTokenString, _ := expiredToken.SignedString([]byte("test-secret"))

	// No mock setup for IsTokenRevoked needed - it should *not* be called

	// Call ValidateToken
	_, err := tokenService.ValidateToken(ctx, expiredTokenString)

	// Assertions: We *expect* an error due to expiration
	assert.Error(t, err)
	assert.ErrorIs(t, err, jwt.ErrTokenExpired) // Check for *specific* error

	mockRepo.AssertExpectations(t)
}

func TestTokenService_ValidateToken_Revoked(t *testing.T) {
	mockRepo := new(MockTokenRepository)
	tokenService := NewTokenService(mockRepo, []byte("test-secret"))
	ctx := context.Background()
	userID := uuid.New() // Consistent user ID

	// Create a token that's otherwise valid, but we'll *pretend* it's revoked
	revokedJti := uuid.New().String() // The JTI we'll "revoke"
	claimsMap := jwt.MapClaims{
		"sub": userID.String(),                  // Use consistent user ID
		"exp": time.Now().Add(time.Hour).Unix(), // Not expired
		"jti": revokedJti,                       // Set the JTI
	}
	revokedToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claimsMap)
	revokedTokenString, _ := revokedToken.SignedString([]byte("test-secret"))

	// Configure the mock:  IsTokenRevoked *will* be called with the revoked JTI
	mockRepo.On("IsTokenRevoked", ctx, revokedJti).Return(true, nil)

	// Call ValidateToken
	_, err := tokenService.ValidateToken(ctx, revokedTokenString)

	// Assertions: We *expect* a "token has been revoked" error
	assert.Error(t, err)
	assert.EqualError(t, err, "token has been revoked") // Check for *specific* error

	mockRepo.AssertExpectations(t)
}


===== File: ./internal/service/password_checker.go =====
package service

import "golang.org/x/crypto/bcrypt"

// PasswordChecker interface defines the contract for password checking.
type PasswordChecker interface {
	CheckPasswordHash(password, hash string) bool
}

// bcryptPasswordChecker is a concrete implementation using bcrypt.
type bcryptPasswordChecker struct{}

// CheckPasswordHash implements the PasswordChecker interface using bcrypt.
func (b *bcryptPasswordChecker) CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

// NewBcryptPasswordChecker creates a new instance of bcryptPasswordChecker.
func NewBcryptPasswordChecker() *bcryptPasswordChecker {
	return &bcryptPasswordChecker{}
}


===== File: ./internal/service/user_service.go =====
package service

import (
	"context"
	"fmt"

	"github.com/tomascosta29/CostaAuth/internal/model"
	"github.com/tomascosta29/CostaAuth/internal/repository"
	"golang.org/x/crypto/bcrypt"
)

type UserServiceInterface interface {
	RegisterUser(ctx context.Context, req *model.RegisterRequest) (*model.User, error)
	LoginUser(ctx context.Context, req *model.LoginRequest) (*model.User, error)
	HashPassword(password string) (string, error) // keep this here
}

type UserService struct {
	userRepo        repository.UserRepository
	passwordChecker PasswordChecker // Add the dependency
}

// Update the constructor to accept the PasswordChecker
func NewUserService(userRepo repository.UserRepository, passwordChecker PasswordChecker) *UserService {
	return &UserService{userRepo: userRepo, passwordChecker: passwordChecker}
}

// ... (RegisterUser function - see below for changes) ...
func (s *UserService) RegisterUser(ctx context.Context, req *model.RegisterRequest) (*model.User, error) {
	// Check if the username or email already exists
	existingUser, err := s.userRepo.GetUserByUsername(ctx, req.Username)
	if err != nil {
		return nil, err
	}
	if existingUser != nil {
		return nil, fmt.Errorf("username already exists")
	}
	existingUser, err = s.userRepo.GetUserByEmail(ctx, req.Email) // add GetUserByEmail to repo interface + impl
	if err != nil {
		return nil, err
	}
	if existingUser != nil {
		return nil, fmt.Errorf("email already exists")
	}

	// Hash the password
	hashedPassword, err := s.HashPassword(req.Password)
	if err != nil {
		return nil, err
	}

	// Create the user
	newUser := &model.User{
		Username:     req.Username,
		Email:        req.Email,
		PasswordHash: hashedPassword,
		IsActive:     true, // Or false, if you require email verification
	}

	err = s.userRepo.CreateUser(ctx, newUser)
	if err != nil {
		return nil, err
	}

	return newUser, nil
}

func (s *UserService) LoginUser(ctx context.Context, req *model.LoginRequest) (*model.User, error) {
	user, err := s.userRepo.GetUserByUsername(ctx, req.Username)
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Use the injected PasswordChecker
	if !s.passwordChecker.CheckPasswordHash(req.Password, user.PasswordHash) {
		return nil, fmt.Errorf("invalid credentials")
	}

	return user, nil
}

// HashPassword hashes a password using bcrypt
func (s *UserService) HashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedPassword), nil
}


===== File: ./internal/service/user_service_test.go =====
package service

import (
	"context"
	"errors"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/tomascosta29/CostaAuth/internal/model"
)

// Mock UserRepository for testing the service
type MockUserRepository struct {
	mock.Mock
}

func (m *MockUserRepository) CreateUser(ctx context.Context, user *model.User) error {
	args := m.Called(ctx, user)
	return args.Error(0)
}

func (m *MockUserRepository) GetUserByUsername(ctx context.Context, username string) (*model.User, error) {
	args := m.Called(ctx, username)
	if args.Get(0) == nil { // important for nil returns
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserRepository) GetUserByID(ctx context.Context, id uuid.UUID) (*model.User, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil { // important for nil returns
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserRepository) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	args := m.Called(ctx, email)
	if args.Get(0) == nil { // important for nil returns
		return nil, args.Error(1)
	}
	return args.Get(0).(*model.User), args.Error(1)
}

// Mock PasswordChecker
type MockPasswordChecker struct {
	mock.Mock
}

func (m *MockPasswordChecker) CheckPasswordHash(password, hash string) bool {
	args := m.Called(password, hash)
	return args.Bool(0)
}

func TestUserService_RegisterUser(t *testing.T) {
	mockRepo := new(MockUserRepository)
	mockChecker := new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService := NewUserService(mockRepo, mockChecker) // Inject the dependency
	ctx := context.Background()

	// Test case: Successful registration
	req := &model.RegisterRequest{
		Username: "newuser",
		Email:    "newuser@example.com",
		Password: "password123",
	}
	// Mock GetUserByUsername to return nil, nil (user not found)
	mockRepo.On("GetUserByUsername", ctx, req.Username).Return((*model.User)(nil), nil)
	mockRepo.On("GetUserByEmail", ctx, req.Email).Return((*model.User)(nil), nil)

	// Mock CreateUser to return nil (no error)
	mockRepo.On("CreateUser", ctx, mock.AnythingOfType("*model.User")).Return(nil)

	user, err := userService.RegisterUser(ctx, req)
	assert.NoError(t, err)
	assert.NotNil(t, user)
	assert.Equal(t, req.Username, user.Username)
	assert.NotEmpty(t, user.PasswordHash) // Check that password was hashed

	// Test case: Username already exists
	mockRepo = new(MockUserRepository) // Reset mock for next scenario
	mockChecker = new(MockPasswordChecker)
	userService = NewUserService(mockRepo, mockChecker)

	existingUser := &model.User{Username: "existinguser"}
	mockRepo.On("GetUserByUsername", ctx, "existinguser").Return(existingUser, nil)

	req = &model.RegisterRequest{
		Username: "existinguser",
		Email:    "existing@example.com",
		Password: "password123",
	}
	_, err = userService.RegisterUser(ctx, req)
	assert.Error(t, err)
	assert.EqualError(t, err, "username already exists") // check for specific error

	// Test case: Email already exists
	mockRepo = new(MockUserRepository) // Reset mock for next scenario
	mockChecker = new(MockPasswordChecker)
	userService = NewUserService(mockRepo, mockChecker)

	existingUser = &model.User{Email: "existing@email.com"}
	mockRepo.On("GetUserByUsername", ctx, "newuser").Return((*model.User)(nil), nil)
	mockRepo.On("GetUserByEmail", ctx, "existing@email.com").Return(existingUser, nil)
	req = &model.RegisterRequest{
		Username: "newuser",
		Email:    "existing@email.com",
		Password: "password123",
	}
	_, err = userService.RegisterUser(ctx, req)
	assert.Error(t, err)
	assert.EqualError(t, err, "email already exists") // check for specific error

	// Test case: CreateUser returns an error
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)
	userService = NewUserService(mockRepo, mockChecker)

	mockRepo.On("GetUserByUsername", ctx, "newuser").Return((*model.User)(nil), nil)          // User not found
	mockRepo.On("GetUserByEmail", ctx, "newuser@example.com").Return((*model.User)(nil), nil) // User not found

	mockRepo.On("CreateUser", ctx, mock.AnythingOfType("*model.User")).Return(errors.New("database error"))

	req = &model.RegisterRequest{Username: "newuser", Email: "newuser@example.com", Password: "password123"}
	_, err = userService.RegisterUser(ctx, req)
	assert.Error(t, err) // Check for any error

	mockRepo.AssertExpectations(t) // Ensure all expected calls were made
	mockChecker.AssertExpectations(t)
}

func TestUserService_LoginUser(t *testing.T) {
	mockRepo := new(MockUserRepository)
	mockChecker := new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService := NewUserService(mockRepo, mockChecker) // Inject *both* mocks
	ctx := context.Background()

	// --- Test case: Successful login ---
	req := &model.LoginRequest{Username: "testuser", Password: "password123"}
	existingUser := &model.User{
		ID:           uuid.New(),
		Username:     "testuser",
		Email:        "test@example.com",
		PasswordHash: "$2a$10$somehashedpassword", // Example bcrypt hash
		IsActive:     true,
	}
	mockRepo.On("GetUserByUsername", ctx, "testuser").Return(existingUser, nil)
	mockChecker.On("CheckPasswordHash", "password123", "$2a$10$somehashedpassword").Return(true) // Mock the checker

	user, err := userService.LoginUser(ctx, req)
	assert.NoError(t, err)
	assert.NotNil(t, user)
	assert.Equal(t, existingUser, user)

	// Reset Mocks
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService = NewUserService(mockRepo, mockChecker) // Inject *both* mocks

	// --- Test case: Wrong password ---
	req = &model.LoginRequest{Username: "testuser", Password: "wrongpassword"}
	mockRepo.On("GetUserByUsername", ctx, "testuser").Return(existingUser, nil)
	mockChecker.On("CheckPasswordHash", "wrongpassword", "$2a$10$somehashedpassword").Return(false) // Mock to fail

	user, err = userService.LoginUser(ctx, req)
	assert.Error(t, err)
	assert.Nil(t, user)
	assert.EqualError(t, err, "invalid credentials")

	// --- Test case: User not found ---
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService = NewUserService(mockRepo, mockChecker) // Inject *both* mocks
	mockRepo.On("GetUserByUsername", ctx, "nonexistentuser").Return((*model.User)(nil), nil)

	req = &model.LoginRequest{Username: "nonexistentuser", Password: "password123"}
	_, err = userService.LoginUser(ctx, req)
	assert.Error(t, err)
	assert.Nil(t, user)
	assert.EqualError(t, err, "invalid credentials")

	// --- Test case: GetUserByUsername returns an error ---
	mockRepo = new(MockUserRepository)
	mockChecker = new(MockPasswordChecker)              // Create a mock PasswordChecker
	userService = NewUserService(mockRepo, mockChecker) // Inject *both* mocks

	mockRepo.On("GetUserByUsername", ctx, "erroruser").Return((*model.User)(nil), errors.New("database error"))
	req = &model.LoginRequest{Username: "erroruser", Password: "password123"}
	_, err = userService.LoginUser(ctx, req)
	assert.Error(t, err)
	assert.Nil(t, user)

	mockRepo.AssertExpectations(t)
	mockChecker.AssertExpectations(t)
}

func TestUserService_HashPassword(t *testing.T) {
	mockRepo := new(MockUserRepository)
	mockChecker := new(MockPasswordChecker)
	userService := NewUserService(mockRepo, mockChecker)

	password := "password123"
	hashedPassword, err := userService.HashPassword(password)
	assert.NoError(t, err)
	assert.NotEmpty(t, hashedPassword)           // Check that hash is not empty
	assert.NotEqual(t, password, hashedPassword) // Check that hash is different from the original

	mockRepo.AssertExpectations(t)
	mockChecker.AssertExpectations(t)
}


===== File: ./internal/security/password.go =====
package security

import "golang.org/x/crypto/bcrypt"

// HashPassword hashes a password using bcrypt
func HashPassword(password string) (string, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", err
	}
	return string(hashedPassword), nil
}

// CheckPasswordHash compares a password with its hash
func CheckPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}


===== File: ./source.go =====




